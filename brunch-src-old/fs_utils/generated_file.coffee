'use strict'

async = require 'async'
debug = require('debug')('brunch:generated-file')
fs = require 'fs'
sysPath = require 'path'
logger = require 'loggy'

# underscore
exports.flatten = (array) ->
  array.reduce (acc, elem) ->
    acc.concat(if Array.isArray(elem) then flatten(elem) else [elem])
  , []

sortAlphabetically = (a, b) ->
  if a < b
    -1
  else if a > b
    1
  else
    0

# If item path starts with 'vendor', it has bigger priority.
sortByVendor = (config, a, b) ->
  aIsVendor = config.vendorConvention a
  bIsVendor = config.vendorConvention b
  if aIsVendor and not bIsVendor
    -1
  else if not aIsVendor and bIsVendor
    1
  else
    # All conditions were false, we don't care about order of
    # these two items.
    sortAlphabetically a, b

# Items wasn't found in config.before, try to find then in
# config.after.
# Item that config.after contains would have lower sorting index.
sortByAfter = (config, a, b) ->
  indexOfA = config.after.indexOf a
  indexOfB = config.after.indexOf b
  [hasA, hasB] = [(indexOfA isnt -1), (indexOfB isnt -1)]
  if hasA and not hasB
    1
  else if not hasA and hasB
    -1
  else if hasA and hasB
    indexOfA - indexOfB
  else
    sortByVendor config, a, b

# Try to find items in config.before.
# Item that config.after contains would have bigger sorting index.
sortByBefore = (config, a, b) ->
  indexOfA = config.before.indexOf a
  indexOfB = config.before.indexOf b
  [hasA, hasB] = [(indexOfA isnt -1), (indexOfB isnt -1)]
  if hasA and not hasB
    -1
  else if not hasA and hasB
    1
  else if hasA and hasB
    indexOfA - indexOfB
  else
    sortByAfter config, a, b

# Sorts by pattern.
#
# Examples
#
#   sort ['b.coffee', 'c.coffee', 'a.coffee'],
#     before: ['a.coffee'], after: ['b.coffee']
#   # => ['a.coffee', 'c.coffee', 'b.coffee']
#
# Returns new sorted array.
exports.sortByConfig = (files, config) ->
  if toString.call(config) is '[object Object]'
    cfg =
      before: config.before ? []
      after: config.after ? []
      vendorConvention: (config.vendorConvention ? -> no)
    files.slice().sort (a, b) -> sortByBefore cfg, a, b
  else
    files

[sortByConfig, sortByBefore, sortByAfter, sortByVendor, sortAlphabetically]

extractOrder = (files, config) ->
  types = files.map (file) -> file.type + 's'
  orders = Object.keys(config.files)
    .filter (key) ->
      key in types
    .map (key) ->
      config.files[key].order ? {}

  before = exports.flatten orders.map (type) -> (type.before ? [])
  after = exports.flatten orders.map (type) -> (type.after ? [])
  vendorConvention = config._normalized.conventions.vendor
  {before, after, vendorConvention}

sort = (files, config) ->
  paths = files.map (file) -> file.path
  indexes = Object.create(null)
  files.forEach (file, index) -> indexes[file.path] = file
  order = extractOrder files, config
  exports.sortByConfig(paths, order).map (path) ->
    indexes[path]

getTestFiles = (config) ->
  isTestFile = (generatedFile) ->
    generatedFile.indexOf(sysPath.normalize 'test/') is 0 and
    generatedFile.indexOf('vendor') is -1

  joinPublic = (generatedFile) ->
    sysPath.join(config.paths.public, generatedFile)

  joinTo = config.files.javascripts.joinTo
  files = if typeof joinTo is 'string' then [joinTo] else Object.keys(joinTo)
  files.filter(isTestFile).map(joinPublic)

cachedTestFiles = null

exports.findTestFiles = (config) ->
  cachedTestFiles ?= getTestFiles config

loadTestFiles = (files, testsConvention) ->
  files
    .map (file) ->
      file.path
    .filter (path) ->
      testsConvention path
    .map (path) ->
      path = path.replace RegExp('\\\\', 'g'), '/'
      path.substring 0, path.lastIndexOf '.'
    .map (path) ->
      "window.require('#{path}');"
    .join('\n') + '\n'

# fs.writeFile + mkdirp.
# Create file if it doesn't exist and writes data to it.
# Would also create a parent directories if they don't exist.
#
# path - String. Path to file that would be written.
# data - String. Data to be written.
# callback(error, path, data) - would be executed on error or on
#    successful write.
#
# Example
#
#   writeFile 'test.txt', 'data', (error) -> console.log error if error?
#
# Returns nothing.
exports.writeFileMkdirp = (path, data, callback) ->
  debug "Writing file '#{path}'"
  write = (callback) -> fs.writeFile path, data, callback
  write (error) ->
    return callback null, path, data unless error?
    mkdirp (sysPath.dirname path), 0o755, (error) ->
      return callback error if error?
      write (error) ->
        callback error, path, data

# File which is generated by brunch from other files.
module.exports = class GeneratedFile
  #
  # path        - path to file that will be generated.
  # sourceFiles - array of `fs_utils.SourceFile`-s.
  # config      - parsed application config.
  #
  constructor: (@path, @sourceFiles, @config, minifiers) ->
    @type = if @sourceFiles.some((file) -> file.type is 'javascript')
      'javascript'
    else
      'stylesheet'
    @minifier = minifiers.filter((minifier) => minifier.type is @type)[0]
    @isTestFile = @path in exports.findTestFiles @config
    Object.freeze this

  # Private: Collect content from a list of files and wrap it with
  # require.js module definition if needed.
  # Returns string.
  _join: (files, callback) ->
    debug "Joining files '#{files.map((file) -> file.path).join(', ')}'
 to '#{@path}'"
    requireFiles = => loadTestFiles files, @config._normalized.conventions.tests
    joined = files.map((file) -> file.cache.data).join('')
    process.nextTick =>
      if @type is 'javascript'
        data = @config._normalized.modules.definition(@path, joined) + joined
        callback null, (if @isTestFile then data + requireFiles() else data)
      else
        callback null, joined

  # Private: minify data.
  #
  # data     - string of js / css that will be minified.
  # callback - function that would be executed with (minifyError, data).
  #
  # Returns nothing.
  _minify: (data, callback) ->
    if @config.optimize
      minify = @minifier?.optimize ? @minifier?.minify
      minify? data, @path, callback
    else
      callback null, data

  # Joins data from source files, minifies it and writes result to
  # path of current generated file.
  #
  # callback - minify / write error or data of written file.
  #
  # Returns nothing.
  write: (callback) ->
    @_join (sort @sourceFiles, @config), (error, joined) =>
      return callback error if error?
      @_minify joined, (error, data) =>
        return callback error if error?
        exports.writeFileMkdirp @path, data, callback
